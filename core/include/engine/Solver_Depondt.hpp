template<>
inline void Method_Solver<Solver::Depondt>::Initialize()
{
    this->forces         = std::vector<vectorfield>( this->noi, vectorfield( this->nos, { 0, 0, 0 } ) );
    this->forces_virtual = std::vector<vectorfield>( this->noi, vectorfield( this->nos, { 0, 0, 0 } ) );

    this->forces_predictor         = std::vector<vectorfield>( this->noi, vectorfield( this->nos, { 0, 0, 0 } ) );
    this->forces_virtual_predictor = std::vector<vectorfield>( this->noi, vectorfield( this->nos, { 0, 0, 0 } ) );

    this->rotationaxis        = std::vector<vectorfield>( this->noi, vectorfield( this->nos, { 0, 0, 0 } ) );
    this->angle               = scalarfield( this->nos, 0 );
    this->forces_virtual_norm = std::vector<scalarfield>( this->noi, scalarfield( this->nos, 0 ) );

    this->configurations_predictor = std::vector<std::shared_ptr<vectorfield>>( this->noi );
    for( int i = 0; i < this->noi; i++ )
        configurations_predictor[i] = std::shared_ptr<vectorfield>( new vectorfield( this->nos, { 0, 0, 0 } ) );

    this->temp1 = vectorfield( this->nos, { 0, 0, 0 } );
}

namespace
{
// TODO get rid of this, currently necessary for CUDA code generation with Clang
// when called from Kernels generated by stdexec senders
// Eigen::cross is apparently not an inline function...
HOSTDEVICEQUALIFIER
Vector3 rotated( const Vector3 & v, const Vector3 & axis, scalar angle )
{
    const auto ca = std::cos( angle );
    return Vector3{ v * ca + axis.cross( v ) * std::sin( angle ) + axis * axis.dot( v ) * ( 1 - ca ) };
}
} // namespace

/*
    Template instantiation of the Simulation class for use with the Depondt Solver.
        The Depondt method is an improvement of Heun's method for spin systems. It applies
        rotations instead of finite displacements and thus avoids re-normalizations.
    Paper: Ph. Depondt et al., Spin dynamics simulations of two-dimensional clusters with
           Heisenberg and dipole-dipole interactions, J. Phys. Condens. Matter 21, 336005 (2009).
*/
template<>
inline void Method_Solver<Solver::Depondt>::Iteration()
{
    using namespace Execution;

    // Generate random vectors for this iteration
    this->Prepare_Thermal_Field();

    // Get the actual forces on the configurations
    this->Calculate_Force( this->configurations, this->forces );
    this->Calculate_Force_Virtual( this->configurations, this->forces, this->forces_virtual );

    // Predictor for each image
    for( int img = 0; img < this->noi; ++img )
    {
        auto vforces        = const_view_of( forces_virtual[img] );
        auto conf           = const_view_of( *this->configurations[img] );
        auto rot_axis       = view_of( rotationaxis[img] );
        auto rot_angle      = view_of( angle );
        auto conf_predictor = view_of( *this->configurations_predictor[img] );

        generate_indexed(
            exec_context, conf_predictor,
            [=]( std::size_t i )
            {
                // For Rotation matrix R := R( H_normed, angle )
                rot_angle[i] = vforces[i].norm();
                rot_axis[i]  = vforces[i];
                rot_axis[i].normalize();
                // Get spin predictor n' = R(H) * n
                return rotated( conf[i], rot_axis[i], rot_angle[i] );
            } );
    }

    // Calculate_Force for the Corrector
    this->Calculate_Force( this->configurations_predictor, this->forces_predictor );
    this->Calculate_Force_Virtual(
        this->configurations_predictor, this->forces_predictor, this->forces_virtual_predictor );

    // Corrector step for each image
    for( int img = 0; img < this->noi; img++ )
    {
        auto vforces           = const_view_of( forces_virtual[img] );
        auto vforces_predictor = const_view_of( forces_virtual_predictor[img] );
        auto conf_predictor    = const_view_of( *this->configurations_predictor[img] );
        auto rot_angle         = view_of( angle );
        auto temp              = view_of( temp1 );
        auto conf              = view_of( *this->configurations[img] );

        generate_indexed(
            exec_context, conf,
            [=]( std::size_t i )
            {
                // Calculate the linear combination of the two forces_virtuals
                // H = (H + H')/2
                temp[i] = 0.5 * ( vforces[i] + vforces_predictor[i] );
                // Get the rotation angle as norm of temp ...For Rotation matrix R' := R( H'_normed, angle' )
                // angle' = |forces_virtual lin combination|
                rot_angle[i] = temp[i].norm();
                // Normalize temp to get rotation axes
                temp[i].normalize();
                // Get new spin conf n_new = R( (H+H')/2 ) * n
                return rotated( conf[i], temp[i], rot_angle[i] );
            } );
    }
}

template<>
inline std::string Method_Solver<Solver::Depondt>::SolverName()
{
    return "Depondt";
}

template<>
inline std::string Method_Solver<Solver::Depondt>::SolverFullName()
{
    return "Depondt";
}
